<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> ü§î Taken for Granted? It's time we reconsider the Instruction Tuning Loss! üëâ | Kowndinya Renduchintala </title> <meta name="author" content="Hari Sri Venkata Naga Sai Kowndinya Renduchintala"> <meta name="description" content="Uncovering the benefits of Weighted Instruction Tuning (WIT)"> <meta name="keywords" content="kowndinya-renduchintala"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/robot-thinking.avif?2fa9026c07e9fd62db704365d6a647b6"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://kowndinya-renduchintala.github.io/blog/2025/wit/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "ü§î Taken for Granted? It's time we reconsider the Instruction Tuning Loss! üëâ",
            "description": "Uncovering the benefits of Weighted Instruction Tuning (WIT)",
            "published": "July 30, 2025",
            "authors": [
              
              {
                "author": "H S V N S Kowndinya Renduchintala",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "MDSR, Adobe",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Kowndinya Renduchintala </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/notes/index.html">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/gallery/">Gallery </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>ü§î Taken for Granted? It's time we reconsider the Instruction Tuning Loss! üëâ</h1> <p>Uncovering the benefits of Weighted Instruction Tuning (WIT)</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#tl-dr">TL;DR</a> </div> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#weighted-instruction-tuning-wit">Weighted Instruction Tuning (WIT)</a> </div> <div> <a href="#so-does-it-work">So...Does it work?</a> </div> <div> <a href="#some-hints-for-future-research">Some Hints for Future Research</a> </div> <div> <a href="#conclusion-and-future-directions">Conclusion and Future Directions</a> </div> </nav> </d-contents> <h2 id="tl-dr">TL;DR ‚Äî Small Tweaks, Big Gains ü§∑</h2> <p>Instruction Tuning is the cornerstone of language model (LM) post-training ‚Äî it is what enables the models to ‚Äúfollow‚Äù user instructions instead of merely completing text. Yet surprisingly, one critical piece has largely flown under the radar: the <strong>Loss Function</strong>!</p> <p>In our recent work, <a href="https://arxiv.org/abs/2507.07817" rel="external nofollow noopener" target="_blank">On the Effect of Instruction Tuning Loss on Generalization</a>(<d-cite key="chatterjee2025effect"></d-cite>), soon to appear in the <em>Transactions of the Association for Computational Linguistics (TACL)</em>, we revisit this overlooked choice and introduce Weighted Instruction Tuning (WIT) ‚Äî a simple yet effective alternative that lets you assign different weights to prompt and response tokens during training.</p> <p>We found that assigning a low-to-moderate (0-0.5) weight to the prompt tokens and a moderate-to-high (0.5-1) weight to the response tokens consistently yields best-performing models across settings ‚Äî when tested extensively across five models (spanning sizes and families), three instruction tuning datasets (varying sizes), and five diverse benchmarks‚Ä¶</p> <p>WIT-finetuned models not only demonstrate consistent improvement in generalization (average relative gain of 6.55%), but also are more robust to minor changes in prompts as well as serve as a stronger bases for subsequent preference alignment tuning!</p> <h2 id="introduction">Introduction ‚Äî The Ubiquitous Loss Function We‚Äôve Barely Scrutinized</h2> <p>Instruction Tuning has emerged as an important step in the post-training phase of LMs. It is what makes today‚Äôs language models capable of ‚Äúfollowing‚Äù user instructions ‚Äî from summarizing a news article to giving life advice in the tone of a pirate!</p> <p>Behind the scenes, instruction tuning works by finetuning a pretrained LM on a collection of (prompt, response) pairs comprising of a diverse set of tasks ‚Äî where prompts encode tasks in the form of natural language instructions and responses provide ideal outputs. But lurking inside nearly every instruction tuning recipe is a crucial detail that has been overlooked:</p> <blockquote> <p>The conventional loss is computed only on the response tokens!</p> </blockquote> <p>But WHY?? üôÇ</p> <p>A couple of recent works have already started questioning it:</p> <ul> <li>Shi et al., 2025 (<d-cite key="shi2025instruction"></d-cite>) treat instruction tuning as a form of continual pretraining, applying loss uniformly over both prompt and response tokens. However, they only find it beneficial when lengthy prompts are coupled with brief responses or when only a small number of training examples are involved.</li> <li>Huerta-Enochian and Ko (2024) (<d-cite key="huerta-enochian-ko-2024-instruction"></d-cite>) proposed using a small non-zero prompt loss weight (PLW) ‚Äî it was found to be beneficial when working with instruction-tuning data containing short completions and that it can safely be ignored when working with instruction-tuning data containing longer completions. However, its applicability across diverse training and evaluation datasets remains unexplored. Moreover, the extent to which prompt token weights should depend solely on the relative length of completions to prompts remains unclear.</li> </ul> <p>Meanwhile, several recent works (<d-cite key="neftune"></d-cite>, <d-cite key="shi2025instruction"></d-cite>, <d-cite key="chu2025sftmemorizesrlgeneralizes"></d-cite>) have raised concerns around models <strong>memorizing response patterns</strong> ‚Äî suggesting that we may be over-tuning on response tokens and hurting generalization‚Ä¶</p> <p>So, this begs the question:</p> <blockquote> <p>What if we assign different weights to prompt and response tokens during training? To control how much to tune on the prompt and response tokens?</p> </blockquote> <p>This is exactly what WIT does ‚Äî it lets you assign different weights to prompt and response tokens during training. And it turns out that this simple tweak goes a long way in improving the generalizability of the model!</p> <h2 id="weighted-instruction-tuning-wit-weighted-instruction-tuning-wit">Weighted Instruction Tuning (WIT) {weighted-instruction-tuning-wit}</h2> <p>Let \(\mathcal{D} = \{(\boldsymbol{P}_i, \boldsymbol{R}_i)\}_{i=1}^{N_{\mathcal{T}}}\) be an instruction tuning dataset with \(N_{\mathcal{T}}\) (prompt, response) pairs. Each prompt \(\boldsymbol{P}_i\) includes an instruction (implicit or explicit) and optionally some input, while \(\boldsymbol{R}_i\) is the expected ground-truth response.</p> <p>If \(\lvert\boldsymbol{S}\rvert\) denotes the number of tokens in a sequence \(\boldsymbol{S}\), then:</p> \[\boldsymbol{P}_i = \left\{p_i^{(1)}, p_i^{(2)}, \ldots, p_i^{(\lvert\boldsymbol{P}_i\rvert)}\right\}\] \[\boldsymbol{R}_i = \left\{r_i^{(1)}, r_i^{(2)}, \ldots, r_i^{(\lvert\boldsymbol{R}_i\rvert)}\right\}\] <p>The WIT loss is given by:</p> \[\mathcal{L}_{WIT} = -\frac{\sum\limits_{i=1}^{N_{\mathcal{T}}}\left[\lambda_p \cdot \sum\limits_{j=1}^{\lvert\boldsymbol{P}_i\rvert} \log \mathbb{P}_{\mathcal{M}}\left(p_i^{(j)} |\; p_i^{(1)},\ldots, p_i^{(j-1)} \right) + \lambda_r \cdot \sum\limits_{j=1}^{\lvert\boldsymbol{R}_i\rvert} \log \mathbb{P}_{\mathcal{M}}\left(r_i^{(j)} |\; r_i^{(1)},\ldots, r_i^{(j-1)} \right)\right]}{\sum\limits_{i=1}^{N_{\mathcal{T}}}\Big(\mathbb{I}{(\lambda_p \neq 0)}\cdot\lvert \boldsymbol{P}_i\rvert + \mathbb{I}{(\lambda_r \neq 0)}\cdot \lvert\boldsymbol{R}_i\rvert\Big)}\] <p>where \(\mathbb{I}(\cdot)\) is the indicator function, \(\lambda_p\) is the prompt token weight, and \(\lambda_r\) is the response token weight. \(\mathcal{L}_{WIT}\) computes the weighted sum of log-probabilities ‚Äì scaling the log-probabilities of prompt tokens by \(\lambda_p\) and those of response tokens by \(\lambda_r\) ‚Äì and then normalizes by the count of tokens with non-zero weight. The indicator function (\(\mathbb{I}\)) ensures that the weighted sum is divided exactly by those tokens whose weight is non-zero. Note that the conventional instruction tuning loss \(\mathcal{L}_{IT}\) is a special case of \(\mathcal{L}_{WIT}\) for \((\lambda_p, \lambda_r) = (0,1)\) and continual pre-training is a special case of \(\mathcal{L}_{WIT}\) for \((\lambda_p, \lambda_r) = (1,1)\).</p> <h2 id="so-does-it-work">So‚Ä¶Does it work?</h2> <p>YES!! And that too consistently, across settings:</p> <p>We ran an extensive set of experiments to test WIT across a wide range of settings. Here‚Äôs what we varied:</p> <ul> <li> <strong>5 Language Models</strong>: LLaMA-3 (1B, 3B, 8B), Gemma-2B, and Mistral-7B</li> <li> <strong>3 Instruction Tuning Datasets</strong>: LIMA (1K high-quality prompts), Alpaca-Cleaned (52K), and T√ºlu-v2 (150K diverse examples)</li> <li> <strong>5 Diverse Evaluation Benchmarks</strong>: spanning knowledge (MMLU), reasoning (BBH), instruction following (IFEval), and conversation (AlpacaEval, MT-Bench)</li> </ul> <p>Across the board, WIT outperforms the conventional instruction tuning loss</p> <ul> <li>On average, WIT achieves a relative gain of 6.55% over the standard loss.</li> <li>In some cases, the relative gains are huge ‚Äî for example, +20.25% for Mistral-7B on Alpaca-Cleaned!</li> <li>Even better: these models serve as a stronger base for subsequent preference alignment tuning (e.g., DPO)! ‚Äî for more details, please refer to our paper!</li> </ul> <div class="single-image" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/wit/main_heatmap-480.webp 480w,/assets/img/wit/main_heatmap-800.webp 800w,/assets/img/wit/main_heatmap-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/wit/main_heatmap.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="image-caption" style="font-size: 0.93em; color: #666; margin-top: 0;"> <em>Figure 1: Heatmaps depicting average performance across five benchmarks (MMLU, BBH, AlpacaEval, IFEval and MT-Bench) for different configurations of (Œªp, Œªr) and for different models finetuned on TuÃàlu-v2, Alpaca-Cleaned, and LIMA. Best performing configuration is highlighted with a red circle. The color map is based on relative gain with respect to conventional instruction tuning. Rows correspond to prompt token weights (Œªp) and columns correspond to response token weights (Œªr). Conventional instruction tuning is marked with IT and base model performance is marked with Base.</em> </div> </div> <h3 id="key-observations">Key Observations:</h3> <ul> <li> <strong>Low-to-Moderate Prompt-Token Weight Yields Best Performing Models.</strong> In ~81% of (model, training data, evaluation benchmark) combinations (61 out of 75), the best results were achieved when prompt tokens had low-to-moderate (0-0.6) weights. Furthermore, in 56% of the combinations, (43 out of 75), the optimal prompt-token weight is non-zero, strongly suggesting that ignoring prompt tokens for instruction tuning is suboptimal.</li> <li> <strong>Moderate-to-High Response-Token Weight Yields Optimal Models.</strong> \(\lambda_r = 1\) (i.e., full weight on response tokens) was optimal in only 24% of the (model, training data, evaluation benchmark) combinations (18 out of 75). Furthermore, in ~73.33% of the combinations, (55 out of 75), a moderate-to-high (0.4-1) response-token weight, yielded the best performance.</li> <li> <strong>Varying Effects of Response-Token Weight on Instruction Adherence and Conversational Fluency.</strong> For IFEval, which measures instruction-following ability, lower response weights are favoured ‚Äì in 60% of (model, training data) combinations (9 out of 15), \(\lambda_r ‚â§ 0.4\) is optimal. In contrast, conversational fluency benchmarks ‚Äì AlpacaEval and MT-Bench ‚Äì‚Äì prefer relatively higher response weights ‚Äì‚Äì in 60% of combinations, (18 out of 30), \(\lambda_r ‚â• 0.6\) is optimal, and in 80% cases, \(\lambda_r ‚â• 0.4\) yields best performance.</li> <li> <strong>Prompt-Only Tuning Also Enhances Base Model Capabilities.</strong> Even when no loss is applied on response tokens, i.e., tuning exclusively on prompts can also improve instruction adherence ‚Äî especially with large/diverse datasets (like T√ºlu-v2).</li> </ul> <h2 id="some-hints-for-future-research">üîÆ Some Hints for Future Research</h2> <p>Building on the empirical results, we looked at broader patterns and preliminary insights that could inspire future studies on the interplay between task characteristics and token weighting:</p> <div class="single-image" style="text-align: center;"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/wit/correlation_table-480.webp 480w,/assets/img/wit/correlation_table-800.webp 800w,/assets/img/wit/correlation_table-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/wit/correlation_table.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="image-caption" style="font-size: 0.93em; color: #666; margin-top: 0;"> <em>Figure 1: Correlation coefficients (Spearman and Kendall‚Äôs œÑ) between the optimal prompt-token weight (Œªp) and various characteristics of the finetuning datasets, evaluation benchmarks and language models.</em> </div> </div> <h3 id="key-trends">Key Trends:</h3> <ul> <li> <strong>Role of finetuning data</strong> While the average optimal prompt-token weight for all finetuning datasets is in the low-to-moderate range, it is comparatively lower for TuÃàlu-v2 compared to Alpaca-Cleaned or LIMA. To better understand the possible dataset characteristics contributing to these trends, we study the prompt characteristics in the finetuning datasets, such as the average prompt length and the average generation ratio (i.e., the ratio of response length and prompt length) to capture the length characteristics, n-gram diversity of prompts to capture lexical diversity, and the average depth of prompts‚Äô dependency parse tree to capture syntactic complexity. We find that the average generation ratio is positively correlated with the optimal prompttoken weight, while the average prompt length exhibits a negative correlation. This indicates that higher prompt-token weights tend to be preferred when the finetuning data contains longer completions relative to prompts, but not necessarily when the prompts themselves are longer. Furthermore, both lexical diversity, as measured by n-gram diversity, and syntactic complexity of the prompts are observed to negatively influence the optimal prompt-token weight.</li> <li> <strong>Role of evaluation benchmarks</strong> We observe that the optimal prompt-token weight varies from low to moderate, ranging from 0.17 for BBH to 0.48 for IFEval. As with finetuning data, a lower prompt-token weight yields better performance on benchmarks with longer prompts; syntactic complexity of the prompts also has a negative correlation with optimal prompttoken weight. However, unlike with training data, we observe that the lexical diversity of evaluation benchmarks is positively correlated with the optimal prompt-token weight.</li> <li> <strong>Role of Language Models</strong> We observe that the optimal prompt-token weight varies from low to moderate, ranging from 0.20 for Llama-3-3B to 0.42 for Gemma-2-2B. To better understand the potential factors contributing to these variations, we obtain model-dependent characteristics of train datasets and evaluation benchmarks, such as the average next-token log probabilities of prompts from finetuning datasets and evaluation benchmarks. The average next-token log probability is observed to be positively correlated with prompt-token weight suggesting that if a model has higher perplexity on prompts of a certain dataset, then a lower prompt-token weight can be more suitable. Furthermore, model size has a weak positive correlation with optimal Œªp.</li> </ul> <h2 id="conclusion-and-future-directions">Conclusion and Future Directions</h2> <ul> <li>The Instruction Tuning Loss is indeed a dial that is worth tuning!</li> <li>Weighted Instruction Tuning (WIT) that assigns low-to-moderate weight to prompt tokens and moderate-to-high weight to response tokens, is a simple yet effective alternative to the conventional instruction tuning loss ‚Äî it also serves as a stronger base for subsequent preference alignment tuning (e.g., DPO)!</li> <li>Future work could explore more adaptive ways to assign weights to individual tokens ‚Äî e.g., based on token informativeness or model perplexity etc!</li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2025-30-07-wit.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> ¬© Copyright 2025 Hari Sri Venkata Naga Sai Kowndinya Renduchintala. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>